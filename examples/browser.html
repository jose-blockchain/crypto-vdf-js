<!DOCTYPE html>
<!--
Copyright 2025 VDF-JS Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VDF.js Browser Example</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 900px;
            margin: 50px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            border-bottom: 3px solid #4CAF50;
            padding-bottom: 10px;
        }
        h2 {
            color: #555;
            margin-top: 30px;
        }
        .input-group {
            margin: 20px 0;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        input, select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            box-sizing: border-box;
        }
        button {
            background: #4CAF50;
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
            margin-top: 10px;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .output {
            margin-top: 20px;
            padding: 15px;
            background: #f9f9f9;
            border-left: 4px solid #4CAF50;
            border-radius: 5px;
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .error {
            border-left-color: #f44336;
            color: #f44336;
        }
        .success {
            border-left-color: #4CAF50;
            color: #4CAF50;
        }
        .loading {
            display: inline-block;
            margin-left: 10px;
        }
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #4CAF50;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîê VDF.js Browser Demo</h1>
        <p>Verifiable Delay Functions in the browser using JavaScript and WebAssembly-like performance.</p>

        <div class="input-group">
            <label for="vdfType">VDF Type:</label>
            <select id="vdfType">
                <option value="pietrzak">Pietrzak (larger proofs, faster verification)</option>
                <option value="wesolowski" selected>Wesolowski (smaller proofs)</option>
            </select>
        </div>

        <div class="input-group">
            <label for="challenge">Challenge (hex):</label>
            <input type="text" id="challenge" value="aa" placeholder="Enter hex string">
        </div>

        <div class="input-group">
            <label for="difficulty">Difficulty (iterations):</label>
            <input type="number" id="difficulty" value="100" min="1" step="1">
            <small>Note: Pietrzak requires even numbers ‚â• 66</small>
        </div>

        <div class="input-group">
            <label for="bitLength">Discriminant Bit Length:</label>
            <select id="bitLength">
                <option value="512">512 bits (fast, less secure)</option>
                <option value="1024">1024 bits (balanced)</option>
                <option value="2048" selected>2048 bits (slow, more secure)</option>
            </select>
        </div>

        <button id="solveBtn" onclick="solveVDF()">Generate Proof</button>
        <button id="verifyBtn" onclick="verifyVDF()" disabled>Verify Proof</button>
        <span id="loadingIndicator" class="loading" style="display:none;">
            <span class="spinner"></span> Computing...
        </span>

        <h2>Output</h2>
        <div id="output" class="output">Click "Generate Proof" to start...</div>
    </div>

    <script src="../dist/browser/vdf.min.js"></script>
    <script>
        let currentProof = null;
        let currentChallenge = null;
        let currentDifficulty = null;
        let currentVdfInstance = null;

        function log(message, type = 'info') {
            const output = document.getElementById('output');
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úì' : '‚Ñπ';
            output.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            output.className = 'output ' + (type === 'error' ? 'error' : type === 'success' ? 'success' : '');
            output.scrollTop = output.scrollHeight;
        }

        function clearLog() {
            document.getElementById('output').textContent = '';
        }

        function hexToBytes(hex) {
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < hex.length; i += 2) {
                bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
            }
            return bytes;
        }

        function bytesToHex(bytes) {
            return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        async function solveVDF() {
            clearLog();
            const solveBtn = document.getElementById('solveBtn');
            const verifyBtn = document.getElementById('verifyBtn');
            const loadingIndicator = document.getElementById('loadingIndicator');

            try {
                const vdfType = document.getElementById('vdfType').value;
                const challengeHex = document.getElementById('challenge').value.replace(/\s/g, '');
                const difficulty = parseInt(document.getElementById('difficulty').value);
                const bitLength = parseInt(document.getElementById('bitLength').value);

                // Validate inputs
                if (!challengeHex || challengeHex.length === 0) {
                    throw new Error('Challenge cannot be empty');
                }
                if (difficulty <= 0) {
                    throw new Error('Difficulty must be positive');
                }

                currentChallenge = hexToBytes(challengeHex);
                currentDifficulty = difficulty;

                log(`Initializing ${vdfType.toUpperCase()} VDF with ${bitLength}-bit discriminant...`);
                
                if (vdfType === 'pietrzak') {
                    currentVdfInstance = new vdf.PietrzakVDFParams(bitLength).new();
                } else {
                    currentVdfInstance = new vdf.WesolowskiVDFParams(bitLength).new();
                }

                log(`Challenge: ${challengeHex}`);
                log(`Difficulty: ${difficulty} iterations`);
                log('Generating proof... This may take a while.');

                solveBtn.disabled = true;
                loadingIndicator.style.display = 'inline-block';

                const startTime = Date.now();
                currentProof = await currentVdfInstance.solve(currentChallenge, currentDifficulty);
                const duration = Date.now() - startTime;

                log(`Proof generated in ${(duration / 1000).toFixed(2)} seconds`, 'success');
                log(`Proof size: ${currentProof.length} bytes`);
                log(`Proof (hex): ${bytesToHex(currentProof).substring(0, 128)}...`);

                verifyBtn.disabled = false;
            } catch (error) {
                log(`Error: ${error.message}`, 'error');
                currentProof = null;
            } finally {
                solveBtn.disabled = false;
                loadingIndicator.style.display = 'none';
            }
        }

        async function verifyVDF() {
            if (!currentProof || !currentVdfInstance) {
                log('No proof to verify. Generate a proof first.', 'error');
                return;
            }

            try {
                log('Verifying proof...');
                const startTime = Date.now();
                
                currentVdfInstance.verify(currentChallenge, currentDifficulty, currentProof);
                
                const duration = Date.now() - startTime;
                log(`Proof verified successfully in ${duration}ms`, 'success');
            } catch (error) {
                log(`Verification failed: ${error.message}`, 'error');
            }
        }

        // Show library info on load
        window.addEventListener('load', () => {
            log('VDF.js library loaded successfully!');
            log('Ready to generate and verify proofs.');
        });
    </script>
</body>
</html>

